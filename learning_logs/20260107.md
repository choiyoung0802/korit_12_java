# 추상 클래스(Abstract Class) (ch13)
- abstract - 추상적인
## 정의
1. 추상 메서드가 하나라도 포함되면 해당 클래스는 추상 클래스로 정의돼야 함.
2. 추상 클래스는 객체를 생성할 수 없음 -> 일반 클래스와의 차이
3. 그 외의 다른 특징은 일반 클래스와 동일함.
- 추상 메서드(abstract method) - 선언만 있고 구현은 없는 메서드
- 추상 클래스(abstract class) - 추상 메서드가 '하나 이상인' 클래스
- 일반 메서드 vs. 추상 메서드 구조 차이
```java
// 일반 메서드
public void showInfo() {
    System.out.println("제 이름은 " + name + "입니다.");
}
public double calcAvg(double[] scores) {
    double sum = 0;
    for (double score : scores) {
        sum+= score;
    }
    double avg = sum / scores.length;
    return avg;
}
// 추상 메서드
public abstract void showInfo(); // 중괄호가 없는 대신 abstract 키워드가 추가됨.
public abstract double calcAvg(double[] scores);
```
### 추상 클래스의 장점
- 코드의 재사용성을 높이고 설계를 보다 명확하게 할 수 있도록 도와준다.
### 추상 클래스의 목적
1. 공통된 기능 제공 : 여러 클래스에서 공통적으로 사용하는 기능을 추상 클래스에서 정의 가능
2. 구체적인 구현 _강제_ : 추상 메서드를 통해 자식 클래스가 '반드시 특정 메서드를' 구현하도록 강제할 수 있음.
3. 코드의 재사용성 : 중복되는 코드를 줄이고, 유지보수성을 향상.

### 주의사항
- 객체 생성을 못합니다.

# 인터페이스(Interface) (ch13)
- Java에서 클래스가 구현해야만 하는 '메서드들'의 집합을 정의하는 일종의 규약(protocol)
- 인터페이스는 메서드의 시그니처(메서드명, 리턴타입, 매개변수 목록)만을 포함하며,
메서드의 실제 구현은 포함하지 않음 -> 추상메서드만 있다는 의미입니다.
- 다중 상속을 지원 -> 이를 통해 클래스가 여러 인터페이스를 '구현'할 수 있음.
    - 추상 클래스는 단일 상속을 지원하기 때문에 상속 과정을 알아보기 쉽다고 방금 전에 수업했는데
    얘는 또 다중 상속을 지원하기 때문에 편하다고 이야기를 합니다.

### 특징
1. 추상 메서드 : 인터페이스 내의 모든 메서드들은 기본적으로 추상 메서드
    - 추상 클래스 내에서는 일반 메서드와 추상 메서드가 둘 다 있을 수 있지만
    인터페이스는 강제적으로 추상 메서드입니다.
2. 상수 : 인터페이스 내에 선언된 변수는 모두 자동으로 public static final 상수로 취급됩니다
-> final 키워드가 변수에 선언되면 어떤 효과가 있었는지 복습할 필요가 있겠네요.
3. 다중 상속 : 클래스는 여러 인터페이스를 구현(implements)할 수 있음.

### 추상 클래스와의 공통점
- 모두 추상 메서드를 포함할 수 있고, 이를 서브 클래스에서 구현해야만 함.

### 추상 클래스와의 차이점
1. 부분 구현 허용 : 추상 클래스는 추상 메서드 뿐만 아니라 일반 메서드도 포함할 수 있다.
2. 상태 저장 가능 : 추상 클래스는 field를 가질 수 있다.
3. 단일 상속 : (일반) 클래스는 하나의 추상 클래스만 상속 받을 수 있다.
4. 생성자 : 추상 클래스는 생성자를 가질 수 있다.
```java
public abstract class Person { // 추상 메서드가 있으니 class 앞에 abstract
    // field 선언
    private String name;
    // AllArgsConstructor
    public Person(String name) {
        this.name = name;
    }
    // method 예시
    public abstract void introduce(); // 추상 메서드가 하나라도 있으면 추상 클래스로 변경해야함.
                                      // 키워드 - abstract
}
// 이상의 추상 클래스를 상속 받는 일반 클래스
public class Student extends Person {
    // 서브 클래스의 field 선언
    private String school;
    // 추상 클래스가 AllArgsConstructor를 가지고 있기 때문에 추상 메서드를 구현 하라는
    // 점에서 빨간 줄 뜰거고, Student 클래스의 생성자를 특정 방식으로 정의하라고 빨간줄이 뜰겁니다.
    
    // 그래서 서브 클래스의 고유 field를 포함한 AllArgsConstructor를 만들어줬습니다.
    public Student(String name, String school) {
        super(name);
        this.school = school;
    }
    
    public void introduce() { // 추상 메서드가 있는 클래스를 상속 받았으니 강제로 재정의 해줘야함.
        System.out.println("재정의");
    }
}
```
이상의 코드라인에서 알 수 있는 점은 추상 클래스가 객체를 직접적으로 생성하지 못한다고
하더라도 추상 클래스의 생성자 정의 방식이 자식 클래스의 생성자 정의 방식을 통제할 수
있다는 점입니다.

그래서 특정 서브 클래스의 객체 생성 방식을 강제하고 싶다면 상속을 통한 방법을 사용할 수 있겠네요.
5. 다양한 접근 제어자(Access Modifier) : 추상 클래스의 메서드와 변수는 다양한 접근제어자를 가질 수 있다.

- 인터페이스
    1. 완전한 추상화 : 인터페이스는 기본적으로 모든 메서드가 추상 메서드(Java 8 이후에 default
     / static 메서드를 사용 가능하긴 합니다).
    2. 인터페이스는 인스턴스 변수(field 중 객체마다 값이 다른 변수를 의미함)를 가질 수 없고,
    상수만 선언 가능
    3. 다중 상속 : 클래스는 여러 인터페이스를 '구현할 수 있다.'(상속 : extends / 구현 :implements)
    4. 생성자 없음 : 인터페이스는 생성자를 가질 수 없다.
        - 인터페이스는 field를 가지지 않으니까 객체마다 다른 값을 가질 수도 없고, 상수만 선언되기 때문에
        (상수는 초기화가 필수적이었습니다), field에 값을 대입하는 것 자체가 불가능하겠네요.
    5. 자동 public : 인터페이스의 메서드들은 자동으로 public이며, 메서드 선언에 접근 제어자를
    명시할 필요 x (근데 Java8 이후로 default/static이 생겼으므로 특정 경우에는 명시해야 할 때도 있음).

- 인터페이스 선언
```java
public interface Press { // class 가 아닌 interface
    String NAME = "button"; // 상수니까 변수명도 대문자로
    /*
        interface이기 때문에 변수 앞에 뭐 굳이 접근 제어자 명시할 필요 x
        final 키워드도 적을 필요가 없습니다.
        하지만 기본적으로 public final이 생략되어있습니다.
        그래서 String 앞에 final을 적더라도 Intellj 상에서 불필요하다고 안내가 나옵니다.

        이하는 안되는 예시들.
     */
//    int age; // 객체마다 다른 값을 적용하기 위한 field 선언 불가능 초기화가 필수 -> 상수라서
//    public Press() {}; // 생성자 정의 불가능 -> 객체 생성이 불가능함
//    void popOut() {
//        System.out.println("일반 메서드를 정의해보았습니다.");
//    } // 인터페이스 상에서는 추상 메서드만 가능합니다. 추상 메서드가 뭐다? 메서드 본문이 없는 메서드.
    // 나머지 로직은 서브 클래스에서 '구현'해야 했습니다.

    // 되는 예시
    void onPressed();   // -> call1() 유형.
}
public interface Up {
    String onUp();
}

public interface Down {
    void onDown();
}
```
- 이상의 인터페이스를 다중 상속(구현)하는 방법
```java
/*
    클래스는 단일 상속만 가능한데, 키워드는 extends
    인터페이스는 다중 상속(구현)이 가능합니다. 키워드는 implements
 */
// 추상 메서드가 하나라도 있으면 클래스도 추상 클래스로 바껴야함 키워드는 abstract
public abstract class Button implements Press, Up, Down{ // 다중 상속(구현)
    @Override
    public void onDown() {} // 일반 메서드 입니다. {}가 있으니까.

    @Override
    public abstract void onPressed(); // 추상 메서드 입니다. {}가 없으니까.

    @Override
    public String onUp() {
        return "";
    }
}
```